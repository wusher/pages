# CSS Wrapped 2025

The Chrome DevRel team just dropped their annual recap of everything CSS and Web UI that shipped in 2025. With 22 new features highlighted, this year marks a significant shift: CSS is no longer just about styling documents—it's becoming a full-fledged tool for handling logic, state, and complex interactions that previously required JavaScript.

Here are the highlights that caught my attention.

## Customizable Select Elements

For decades, the `<select>` element has been a styling nightmare. Its internal structure was locked away by the browser, forcing developers to build custom dropdowns from scratch whenever they needed anything beyond the default look.

That era is ending. With `appearance: base-select`, you can now fully customize the button, dropdown, and individual options. The `::picker(select)` pseudo-element gives you access to the dropdown portion, and `selectedcontent` lets you reflect option markup in the button itself.

```html
<select class="custom-select">
  <option value="apple">Apple</option>
  <option value="banana">Banana</option>
  <option value="cherry">Cherry</option>
</select>

<style>
.custom-select {
  appearance: base-select;
  font-family: inherit;
  font-size: 1rem;
  padding: 0.5rem 1rem;
  border: 2px solid #3b82f6;
  border-radius: 8px;
  background: white;
  cursor: pointer;
}

.custom-select::picker(select) {
  background: white;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  padding: 0.25rem;
}

.custom-select option {
  padding: 0.5rem 1rem;
  border-radius: 4px;
}

.custom-select option:hover {
  background: #eff6ff;
}

.custom-select option:checked {
  background: #3b82f6;
  color: white;
}
</style>
```

**Browser support:** Chrome 134+, Edge 134+. Firefox and Safari show the default select as a graceful fallback—your page never breaks.

## Native CSS Carousels

Creating carousels has historically meant choosing between accessibility nightmares or heavyweight JavaScript libraries. The new `::scroll-button()` and `::scroll-marker()` pseudo-elements change everything.

These features let you create navigation dots and scroll buttons purely with CSS, linked natively to the scroll container. The browser handles proper roles, tab order, and state management automatically.

```html
<div class="carousel">
  <div class="slide">Slide 1</div>
  <div class="slide">Slide 2</div>
  <div class="slide">Slide 3</div>
</div>

<style>
.carousel {
  display: flex;
  overflow-x: auto;
  scroll-snap-type: x mandatory;
  gap: 1rem;
  scroll-marker-group: after;
}

.carousel::scroll-button(prev),
.carousel::scroll-button(next) {
  position: absolute;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: white;
  border: 1px solid #e5e7eb;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  cursor: pointer;
}

.carousel::scroll-button(prev) {
  content: "←";
  left: 1rem;
}

.carousel::scroll-button(next) {
  content: "→";
  right: 1rem;
}

.carousel::scroll-button(:disabled) {
  opacity: 0.5;
  cursor: not-allowed;
}

.slide {
  flex: 0 0 100%;
  scroll-snap-align: start;
  scroll-marker: auto;
}

.carousel::scroll-marker-group {
  display: flex;
  justify-content: center;
  gap: 0.5rem;
  padding: 1rem;
}

.carousel::scroll-marker-group > * {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: #d1d5db;
}

.carousel::scroll-marker-group > :target-current {
  background: #3b82f6;
}
</style>
```

**Browser support:** Chrome 135+, Edge 135+. Firefox and Safari do not yet support these pseudo-elements. Use `@supports selector(::scroll-button(*))` for feature detection.

## Scroll-State Queries

For years, the only way to know if a sticky element was actually stuck, or if a snap item was snapped, was to wire up an IntersectionObserver. Chrome 133 introduced scroll-state queries that let you style based on these states declaratively.

```html
<header class="sticky-header">
  <nav>
    <a href="/">Home</a>
    <a href="/about">About</a>
    <a href="/contact">Contact</a>
  </nav>
</header>

<style>
.sticky-header {
  container-type: scroll-state;
  position: sticky;
  top: 0;
  background: white;
  padding: 1rem;
  transition: box-shadow 0.2s, background 0.2s;
}

@container scroll-state(stuck: top) {
  .sticky-header {
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(8px);
  }

  .sticky-header nav a {
    font-size: 0.9rem;
  }
}

/* For snapped items in a scroll-snap container */
.snap-container {
  container-type: scroll-state;
  scroll-snap-type: x mandatory;
}

.snap-item {
  scroll-snap-align: center;
}

@container scroll-state(snapped: x) {
  .snap-item {
    transform: scale(1.05);
    opacity: 1;
  }
}
</style>
```

**Browser support:** Chrome 133+, Edge 133+. Not yet supported in Firefox or Safari.

## Invoker Commands

Opening dialogs and popovers used to require JavaScript event listeners. With invoker commands, buttons can now perform actions on other elements declaratively using the `commandfor` and `command` attributes.

```html
<!-- Opening a modal dialog -->
<button commandfor="settings-dialog" command="show-modal">
  Open Settings
</button>

<dialog id="settings-dialog">
  <h2>Settings</h2>
  <form method="dialog">
    <label>
      <input type="checkbox" name="notifications">
      Enable notifications
    </label>
    <div class="actions">
      <button commandfor="settings-dialog" command="close">
        Cancel
      </button>
      <button type="submit">Save</button>
    </div>
  </form>
</dialog>

<!-- Controlling popovers -->
<button commandfor="menu" command="toggle-popover">
  Menu
</button>

<div id="menu" popover>
  <a href="/profile">Profile</a>
  <a href="/settings">Settings</a>
  <button commandfor="menu" command="hide-popover">
    Close Menu
  </button>
</div>

<!-- Custom commands -->
<button commandfor="player" command="--play-pause">
  Play/Pause
</button>

<div id="player">
  <script>
    document.getElementById('player').addEventListener('command', (e) => {
      if (e.command === '--play-pause') {
        // Handle custom command
      }
    });
  </script>
</div>
```

Available built-in commands: `show-modal`, `close`, `show-popover`, `hide-popover`, `toggle-popover`. Custom commands use a `--` prefix.

**Browser support:** Chrome 135+, Edge 135+, Opera 120+, Safari Technology Preview, Firefox 144+ (and Nightly behind flag).

## Dialog Light Dismiss

Popovers brought the lovely light dismiss behavior—close by clicking outside or pressing ESC. Now `<dialog>` elements get the same treatment with the `closedby` attribute.

```html
<!-- Click outside or press ESC to close -->
<dialog id="quick-dialog" closedby="any">
  <h2>Quick Action</h2>
  <p>Click outside this dialog to close it.</p>
</dialog>

<!-- Only ESC key closes it -->
<dialog id="confirm-dialog" closedby="closerequest">
  <h2>Confirm Action</h2>
  <p>Press ESC to cancel, or click a button.</p>
  <button commandfor="confirm-dialog" command="close">Cancel</button>
  <button onclick="doAction()">Confirm</button>
</dialog>

<!-- Requires explicit close action -->
<dialog id="important-dialog" closedby="none">
  <h2>Important Notice</h2>
  <p>You must acknowledge this message.</p>
  <button commandfor="important-dialog" command="close">
    I Understand
  </button>
</dialog>

<style>
dialog {
  border: none;
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
  padding: 2rem;
  max-width: 400px;
}

dialog::backdrop {
  background: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(4px);
}
</style>
```

**Browser support:** Chrome 134+, Edge 134+, Firefox 141+. Not yet supported in Safari (vendor position is "support").

## Popover Hints for Layered UI

The new `popover="hint"` type creates popovers that don't close other popovers when they open. Perfect for tooltips that should appear over an already-open menu.

Pair it with the `interestfor` attribute for native, declarative hover/focus-triggered popovers:

```html
<!-- Basic hint popover with interest invoker -->
<button interestfor="tooltip-1">Hover for help</button>
<div id="tooltip-1" popover="hint">
  This tooltip appears on hover without closing other popovers.
</div>

<!-- Layered UI example -->
<button commandfor="main-menu" command="show-popover">
  Open Menu
</button>

<div id="main-menu" popover>
  <button interestfor="submenu-hint">
    Advanced Options →
  </button>
  <div id="submenu-hint" popover="hint">
    <p>These options are for power users.</p>
  </div>

  <button interestfor="delete-hint">
    Delete Account
  </button>
  <div id="delete-hint" popover="hint">
    <p>Warning: This action cannot be undone!</p>
  </div>
</div>

<style>
[popover="hint"] {
  background: #1f2937;
  color: white;
  padding: 0.5rem 1rem;
  border-radius: 6px;
  font-size: 0.875rem;
  max-width: 250px;
  border: none;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

/* Control hover delay */
[interestfor] {
  interest-delay: 300ms;
}
</style>
```

**Browser support:** `popover="hint"` works in Chrome 133+, Edge 133+. The `interestfor` attribute is experimental and requires the `#experimental-web-platform-features` flag in Chrome Canary.

## Corner Shape

Beyond `border-radius`, the new `corner-shape` property lets you customize corner shapes in ways previously impossible. Squircles, bevels, notches, scoops—you can even animate between different corner shapes.

```html
<div class="shape-demo">
  <div class="squircle">Squircle</div>
  <div class="bevel">Bevel</div>
  <div class="scoop">Scoop</div>
  <div class="notch">Notch</div>
  <div class="custom">Custom</div>
</div>

<style>
.shape-demo > div {
  width: 120px;
  height: 120px;
  display: grid;
  place-items: center;
  background: linear-gradient(135deg, #667eea, #764ba2);
  color: white;
  font-weight: 600;
}

/* Smooth iOS-style corners */
.squircle {
  border-radius: 24px;
  corner-shape: squircle;
}

/* Chamfered corners */
.bevel {
  border-radius: 24px;
  corner-shape: bevel;
}

/* Concave curves */
.scoop {
  border-radius: 24px;
  corner-shape: scoop;
}

/* Sharp concave notch */
.notch {
  border-radius: 24px;
  corner-shape: notch;
}

/* Fine-tuned with superellipse */
.custom {
  border-radius: 32px;
  corner-shape: superellipse(3);
}

/* Animated corner morphing */
.shape-demo > div {
  transition: corner-shape 0.3s ease;
}

.shape-demo > div:hover {
  corner-shape: round;
}
</style>
```

Values: `round` (default), `squircle`, `bevel`, `scoop`, `notch`, `superellipse(n)` for fine control.

**Browser support:** Chrome 139+, Edge 139+ (or Chrome 136+ with experimental flag). Not yet supported in Firefox or Safari.

## Anchor Positioning

CSS anchor positioning declaratively tethers one element to another, automatically handling repositioning when it gets close to the edge of the screen. It's now part of Interop 2025, meaning cross-browser support is arriving.

The real news is anchored container queries: you can style elements based on which fallback position the browser actually chose.

```html
<button class="anchor-trigger" style="anchor-name: --trigger">
  Click me
</button>

<div class="tooltip" popover>
  I'm anchored to the button and flip when needed!
  <div class="arrow"></div>
</div>

<style>
.anchor-trigger {
  anchor-name: --trigger;
}

.tooltip {
  position: fixed;
  position-anchor: --trigger;

  /* Position below the anchor by default */
  top: anchor(bottom);
  left: anchor(center);
  translate: -50% 8px;

  /* Flip above if no room below */
  position-try-fallbacks: flip-block;

  background: #1f2937;
  color: white;
  padding: 0.75rem 1rem;
  border-radius: 8px;
  border: none;
  max-width: 300px;
}

/* Arrow positioning */
.arrow {
  position: absolute;
  left: 50%;
  translate: -50% 0;
  border: 6px solid transparent;
}

/* Style based on which position was chosen */
@container style(--position: bottom) {
  .arrow {
    top: -12px;
    border-bottom-color: #1f2937;
  }
}

/* When flipped to top */
.tooltip:has(:target-current) .arrow {
  bottom: -12px;
  top: auto;
  border-top-color: #1f2937;
  border-bottom-color: transparent;
}
</style>
```

**Browser support:** Chrome 125+, Edge 125+, Safari 26.1+. Firefox 147+ (currently in beta, behind flag in stable). Part of Interop 2025 for cross-browser alignment.

## The if() Function

CSS now has conditional logic with the `if()` function. This opens up patterns that previously required preprocessors or JavaScript.

```html
<style>
:root {
  --theme: dark;
  --density: compact;
}

.card {
  /* Conditional based on custom property */
  background: if(
    style(--theme: dark): #1f2937;
    style(--theme: light): #ffffff;
    else: #f3f4f6
  );

  color: if(
    style(--theme: dark): #f9fafb;
    else: #111827
  );

  /* Responsive without media queries in the selector */
  padding: if(
    style(--density: compact): 0.5rem;
    style(--density: comfortable): 1.5rem;
    else: 1rem
  );

  /* Media query conditions inline */
  font-size: if(
    media(width >= 1200px): 1.25rem;
    media(width >= 768px): 1.125rem;
    else: 1rem
  );

  /* Feature detection inline */
  display: if(
    supports(display: grid): grid;
    else: flex
  );
}

/* Combined with CSS custom functions */
@function --spacing(--size) {
  result: if(
    style(--size: sm): 0.5rem;
    style(--size: md): 1rem;
    style(--size: lg): 2rem;
    else: 1rem
  );
}

.element {
  margin: --spacing(--size: lg);
}
</style>
```

Supported conditions: `style()`, `media()`, `supports()`.

**Browser support:** Chrome 137+, Edge 137+. Not yet supported in Firefox or Safari. Always provide fallback values for unsupported browsers.

## What This Means

These features share a common theme: moving complexity out of JavaScript and into the platform. Native carousels, declarative dialogs, scroll-aware styling, conditional logic—the browser handles more, your bundle ships less.

The web platform is maturing. CSS in 2025 isn't the CSS of ten years ago. It's becoming a powerful, ergonomic toolkit for building dynamic applications.

Check out the full interactive experience at [chrome.dev/css-wrapped-2025](https://chrome.dev/css-wrapped-2025/).
