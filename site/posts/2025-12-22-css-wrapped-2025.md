# CSS Wrapped 2025

The Chrome DevRel team just dropped their annual recap of everything CSS and Web UI that shipped in 2025. With 22 new features highlighted, this year marks a significant shift: CSS is no longer just about styling documents—it's becoming a full-fledged tool for handling logic, state, and complex interactions that previously required JavaScript.

Here are the highlights that caught my attention.

## Customizable Select Elements

For decades, the `<select>` element has been a styling nightmare. Its internal structure was locked away by the browser, forcing developers to build custom dropdowns from scratch whenever they needed anything beyond the default look.

That era is ending. With `appearance: base-select`, you can now fully customize the button, dropdown, and individual options.

<div style="padding: 1.5rem; background: #f8fafc; border-radius: 8px; margin: 1.5rem 0;">
  <select style="appearance: base-select; font-family: inherit; font-size: 1rem; padding: 0.5rem 1rem; border: 2px solid #3b82f6; border-radius: 8px; background: white; cursor: pointer;">
    <option value="apple">Apple</option>
    <option value="banana">Banana</option>
    <option value="cherry">Cherry</option>
  </select>
</div>

```css
select {
  appearance: base-select;
}

select::picker(select) {
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

select option:checked {
  background: #3b82f6;
  color: white;
}
```

**Browser support:** Chrome 134+, Edge 134+. Firefox and Safari show the default select as a graceful fallback.

## Native CSS Carousels

Creating carousels has historically meant choosing between accessibility nightmares or heavyweight JavaScript libraries. The new `::scroll-button()` and `::scroll-marker()` pseudo-elements change everything.

<div style="position: relative; padding: 1.5rem; background: #f8fafc; border-radius: 8px; margin: 1.5rem 0;">
  <div style="display: flex; overflow-x: auto; scroll-snap-type: x mandatory; gap: 1rem; scroll-marker-group: after; scrollbar-width: none;">
    <div style="flex: 0 0 calc(100% - 2rem); scroll-snap-align: start; background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 3rem; border-radius: 8px; text-align: center; font-weight: 600;">Slide 1</div>
    <div style="flex: 0 0 calc(100% - 2rem); scroll-snap-align: start; background: linear-gradient(135deg, #f093fb, #f5576c); color: white; padding: 3rem; border-radius: 8px; text-align: center; font-weight: 600;">Slide 2</div>
    <div style="flex: 0 0 calc(100% - 2rem); scroll-snap-align: start; background: linear-gradient(135deg, #4facfe, #00f2fe); color: white; padding: 3rem; border-radius: 8px; text-align: center; font-weight: 600;">Slide 3</div>
  </div>
  <p style="text-align: center; margin-top: 1rem; font-size: 0.875rem; color: #64748b;">Scroll horizontally or use arrow keys. In Chrome 135+, navigation buttons and dots appear automatically.</p>
</div>

```css
.carousel {
  scroll-snap-type: x mandatory;
  scroll-marker-group: after;
}

.carousel::scroll-button(prev) { content: "←"; }
.carousel::scroll-button(next) { content: "→"; }

.slide {
  scroll-snap-align: start;
  scroll-marker: auto;
}
```

**Browser support:** Chrome 135+, Edge 135+. Firefox and Safari do not yet support these pseudo-elements.

## Scroll-State Queries

For years, the only way to know if a sticky element was actually stuck was to wire up an IntersectionObserver. Now you can style based on scroll state declaratively.

<div style="padding: 1.5rem; background: #f8fafc; border-radius: 8px; margin: 1.5rem 0;">
  <div style="height: 150px; overflow-y: auto; border: 1px solid #e2e8f0; border-radius: 8px;">
    <div style="position: sticky; top: 0; background: white; padding: 0.75rem 1rem; font-weight: 600; border-bottom: 1px solid #e2e8f0; container-type: scroll-state;">
      Sticky Header (scroll down)
    </div>
    <div style="padding: 1rem;">
      <p style="margin-bottom: 1rem;">Scroll this container to see the header stick.</p>
      <p style="margin-bottom: 1rem;">In Chrome 133+, you can style the header differently when it's stuck using <code>@container scroll-state(stuck: top)</code>.</p>
      <p style="margin-bottom: 1rem;">This eliminates the need for IntersectionObserver hacks.</p>
      <p>Keep scrolling...</p>
    </div>
  </div>
</div>

```css
.sticky-header {
  container-type: scroll-state;
  position: sticky;
  top: 0;
}

@container scroll-state(stuck: top) {
  .sticky-header {
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    backdrop-filter: blur(8px);
  }
}
```

**Browser support:** Chrome 133+, Edge 133+. Not yet supported in Firefox or Safari.

## Invoker Commands

Opening dialogs and popovers used to require JavaScript event listeners. With invoker commands, buttons can perform actions declaratively.

<div style="padding: 1.5rem; background: #f8fafc; border-radius: 8px; margin: 1.5rem 0;">
  <button commandfor="demo-dialog" command="show-modal" style="padding: 0.5rem 1rem; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem;">
    Open Dialog
  </button>
  <dialog id="demo-dialog" style="border: none; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.2); padding: 1.5rem; max-width: 400px;">
    <h3 style="margin: 0 0 1rem 0;">No JavaScript Required</h3>
    <p style="margin: 0 0 1rem 0; color: #64748b;">This dialog was opened with just HTML attributes. No event listeners needed.</p>
    <button commandfor="demo-dialog" command="close" style="padding: 0.5rem 1rem; background: #e2e8f0; border: none; border-radius: 6px; cursor: pointer;">Close</button>
  </dialog>
  <span style="margin-left: 1rem; color: #64748b; font-size: 0.875rem;">(Works in Chrome 135+)</span>
</div>

```html
<button commandfor="my-dialog" command="show-modal">
  Open Dialog
</button>

<dialog id="my-dialog">
  <p>Hello, world!</p>
  <button commandfor="my-dialog" command="close">Close</button>
</dialog>
```

Available commands: `show-modal`, `close`, `show-popover`, `hide-popover`, `toggle-popover`.

**Browser support:** Chrome 135+, Edge 135+, Opera 120+, Safari Technology Preview, Firefox 144+.

## Dialog Light Dismiss

Popovers brought the lovely light dismiss behavior—close by clicking outside or pressing ESC. Now `<dialog>` elements get the same treatment with the `closedby` attribute.

<div style="padding: 1.5rem; background: #f8fafc; border-radius: 8px; margin: 1.5rem 0;">
  <button commandfor="light-dismiss-dialog" command="show-modal" style="padding: 0.5rem 1rem; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem;">
    Open Light Dismiss Dialog
  </button>
  <dialog id="light-dismiss-dialog" closedby="any" style="border: none; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.2); padding: 1.5rem; max-width: 400px;">
    <h3 style="margin: 0 0 1rem 0;">Click Outside to Close</h3>
    <p style="margin: 0; color: #64748b;">Click anywhere outside this dialog or press ESC to close it. No JavaScript required.</p>
  </dialog>
  <span style="margin-left: 1rem; color: #64748b; font-size: 0.875rem;">(Works in Chrome 134+)</span>
</div>

```html
<dialog closedby="any">
  Click outside or press ESC to close.
</dialog>

<!-- Options: "none" | "closerequest" | "any" -->
```

**Browser support:** Chrome 134+, Edge 134+, Firefox 141+. Not yet supported in Safari.

## Popover Hints for Layered UI

The new `popover="hint"` type creates popovers that don't close other popovers when they open. Perfect for tooltips over menus.

<div style="padding: 1.5rem; background: #f8fafc; border-radius: 8px; margin: 1.5rem 0;">
  <button popovertarget="hint-demo" style="padding: 0.5rem 1rem; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem;">
    Toggle Popover
  </button>
  <div id="hint-demo" popover style="background: #1f2937; color: white; padding: 0.75rem 1rem; border-radius: 8px; border: none; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
    This is a popover. In Chrome 133+, use <code style="background: rgba(255,255,255,0.1); padding: 0.125rem 0.25rem; border-radius: 3px;">popover="hint"</code> for tooltips that layer without closing other popovers.
  </div>
</div>

```html
<button interestfor="tooltip">Hover me</button>
<div id="tooltip" popover="hint">
  Tooltip that doesn't close other popovers
</div>
```

**Browser support:** `popover="hint"` works in Chrome 133+, Edge 133+. The `interestfor` attribute is experimental (requires flag).

## Corner Shape

Beyond `border-radius`, the new `corner-shape` property enables squircles, bevels, scoops, and more.

<div style="padding: 1.5rem; background: #f8fafc; border-radius: 8px; margin: 1.5rem 0;">
  <div style="display: flex; flex-wrap: wrap; gap: 1rem; justify-content: center;">
    <div style="width: 100px; height: 100px; display: grid; place-items: center; background: linear-gradient(135deg, #667eea, #764ba2); color: white; font-weight: 600; font-size: 0.75rem; border-radius: 20px; corner-shape: round;">round</div>
    <div style="width: 100px; height: 100px; display: grid; place-items: center; background: linear-gradient(135deg, #f093fb, #f5576c); color: white; font-weight: 600; font-size: 0.75rem; border-radius: 20px; corner-shape: squircle;">squircle</div>
    <div style="width: 100px; height: 100px; display: grid; place-items: center; background: linear-gradient(135deg, #4facfe, #00f2fe); color: white; font-weight: 600; font-size: 0.75rem; border-radius: 20px; corner-shape: bevel;">bevel</div>
    <div style="width: 100px; height: 100px; display: grid; place-items: center; background: linear-gradient(135deg, #43e97b, #38f9d7); color: white; font-weight: 600; font-size: 0.75rem; border-radius: 20px; corner-shape: scoop;">scoop</div>
    <div style="width: 100px; height: 100px; display: grid; place-items: center; background: linear-gradient(135deg, #fa709a, #fee140); color: white; font-weight: 600; font-size: 0.75rem; border-radius: 20px; corner-shape: notch;">notch</div>
  </div>
  <p style="text-align: center; margin-top: 1rem; font-size: 0.875rem; color: #64748b;">Shapes visible in Chrome 139+. Others see rounded corners.</p>
</div>

```css
.squircle {
  border-radius: 20px;
  corner-shape: squircle;
}

.bevel {
  border-radius: 20px;
  corner-shape: bevel;
}

/* Fine control with superellipse */
.custom {
  corner-shape: superellipse(3);
}
```

**Browser support:** Chrome 139+, Edge 139+. Not yet supported in Firefox or Safari.

## Anchor Positioning

CSS anchor positioning declaratively tethers one element to another, automatically handling repositioning when near edges.

<div style="padding: 1.5rem; background: #f8fafc; border-radius: 8px; margin: 1.5rem 0;">
  <div style="position: relative; height: 120px; display: flex; align-items: center; justify-content: center;">
    <button id="anchor-demo-btn" style="anchor-name: --demo-anchor; padding: 0.5rem 1rem; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem;">
      I'm the anchor
    </button>
    <div style="position: absolute; top: calc(100% - 30px); left: 50%; transform: translateX(-50%); background: #1f2937; color: white; padding: 0.5rem 0.75rem; border-radius: 6px; font-size: 0.875rem; white-space: nowrap;">
      Tooltip anchored below
      <div style="position: absolute; top: -6px; left: 50%; transform: translateX(-50%); border: 6px solid transparent; border-bottom-color: #1f2937;"></div>
    </div>
  </div>
  <p style="text-align: center; font-size: 0.875rem; color: #64748b;">In supporting browsers, the tooltip auto-flips when near viewport edges.</p>
</div>

```css
.trigger {
  anchor-name: --trigger;
}

.tooltip {
  position: fixed;
  position-anchor: --trigger;
  top: anchor(bottom);
  left: anchor(center);
  position-try-fallbacks: flip-block;
}
```

**Browser support:** Chrome 125+, Edge 125+, Safari 26.1+. Firefox 147+ (behind flag). Part of Interop 2025.

## The if() Function

CSS now has conditional logic with the `if()` function, enabling patterns that previously required preprocessors.

<div style="padding: 1.5rem; background: #f8fafc; border-radius: 8px; margin: 1.5rem 0;">
  <div style="display: grid; gap: 1rem; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));">
    <div style="padding: 1rem; background: #1f2937; color: #f9fafb; border-radius: 8px; text-align: center;">Dark theme</div>
    <div style="padding: 1rem; background: #ffffff; color: #111827; border-radius: 8px; text-align: center; border: 1px solid #e2e8f0;">Light theme</div>
  </div>
  <p style="text-align: center; margin-top: 1rem; font-size: 0.875rem; color: #64748b;">In Chrome 137+, theme switching can be done inline with if().</p>
</div>

```css
.card {
  background: if(
    style(--theme: dark): #1f2937;
    style(--theme: light): #ffffff;
    else: #f3f4f6
  );

  font-size: if(
    media(width >= 1200px): 1.25rem;
    media(width >= 768px): 1.125rem;
    else: 1rem
  );
}
```

Supported conditions: `style()`, `media()`, `supports()`.

**Browser support:** Chrome 137+, Edge 137+. Not yet supported in Firefox or Safari.

## What This Means

These features share a common theme: moving complexity out of JavaScript and into the platform. Native carousels, declarative dialogs, scroll-aware styling, conditional logic—the browser handles more, your bundle ships less.

The web platform is maturing. CSS in 2025 isn't the CSS of ten years ago. It's becoming a powerful, ergonomic toolkit for building dynamic applications.

Check out the full interactive experience at [chrome.dev/css-wrapped-2025](https://chrome.dev/css-wrapped-2025/).
