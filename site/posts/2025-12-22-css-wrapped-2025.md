# CSS Wrapped 2025

The Chrome DevRel team just dropped their annual recap of everything CSS and Web UI that shipped in 2025. With 22 new features highlighted, this year marks a significant shift: CSS is no longer just about styling documents—it's becoming a full-fledged tool for handling logic, state, and complex interactions that previously required JavaScript.

Here are the highlights that caught my attention.

## Customizable Select Elements

For decades, the `<select>` element has been a styling nightmare. Its internal structure was locked away by the browser, forcing developers to build custom dropdowns from scratch whenever they needed anything beyond the default look.

That era is ending. With `appearance: base-select`, you can now fully customize the button, dropdown, and individual options. The `::picker(select)` pseudo-element gives you access to the dropdown portion, and `selectedcontent` lets you reflect option markup in the button itself.

```css
select {
  appearance: base-select;
}

select::picker(select) {
  background: white;
  border: 1px solid #ccc;
  border-radius: 8px;
}
```

## Native CSS Carousels

Creating carousels has historically meant choosing between accessibility nightmares or heavyweight JavaScript libraries. The new `::scroll-button()` and `::scroll-marker()` pseudo-elements change everything.

These features let you create navigation dots and scroll buttons purely with CSS, linked natively to the scroll container. The browser handles proper roles, tab order, and state management automatically. Accessible carousels with no JavaScript required.

```css
.carousel {
  scroll-marker-group: after;
}

.carousel > * {
  scroll-marker: true;
}

.carousel::scroll-button(prev) {
  content: "<";
}

.carousel::scroll-button(next) {
  content: ">";
}
```

## Scroll-State Queries

For years, the only way to know if a sticky element was actually stuck, or if a snap item was snapped, was to wire up an IntersectionObserver. Chrome 133 introduced scroll-state queries that let you style based on these states declaratively.

```css
.sticky-header {
  container-type: scroll-state;
}

@container scroll-state(stuck: top) {
  .sticky-header {
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }
}
```

This is a massive quality of life improvement for anyone building scroll-based UI.

## Invoker Commands

Opening dialogs and popovers used to require JavaScript event listeners. With invoker commands, buttons can now perform actions on other elements declaratively using the `commandfor` and `command` attributes.

```html
<button commandfor="my-dialog" command="show-modal">Open</button>
<dialog id="my-dialog">
  <p>Hello, world!</p>
  <button commandfor="my-dialog" command="close">Close</button>
</dialog>
```

No JavaScript. No waiting for scripts to download. Just HTML.

## Dialog Light Dismiss

Popovers brought the lovely light dismiss behavior—close by clicking outside or pressing ESC. Now `<dialog>` elements get the same treatment with the `closedby` attribute:

- `closedby="none"` – No user-triggered closing
- `closedby="closerequest"` – ESC key closes the dialog
- `closedby="any"` – Click outside or ESC closes the dialog

## Popover Hints for Layered UI

The new `popover="hint"` type creates popovers that don't close other popovers when they open. Perfect for tooltips that should appear over an already-open menu.

Pair it with the `interestfor` attribute for native, declarative hover/focus-triggered popovers:

```html
<button interestfor="tooltip" popover="hint">Hover me</button>
<div id="tooltip" popover="hint">Helpful information</div>
```

## Corner Shape

Beyond `border-radius`, the new `corner-shape` property lets you customize corner shapes in ways previously impossible. Squircles, flower-like shapes, hexagonal grids—you can even animate between different corner shapes.

## Anchor Positioning Matures

CSS anchor positioning landed in Chrome 125 and became part of Interop 2025, meaning cross-browser support is coming. But the real news is anchored container queries: you can now style elements based on which fallback position the browser actually chose.

```css
.tooltip {
  position: fixed;
  anchor-name: --trigger;
}

@container anchored(fallback: flip-block) {
  .tooltip::before {
    /* Flip the arrow when tooltip flips */
    transform: rotate(180deg);
  }
}
```

## The if() Function

CSS now has conditional logic with the `if()` function. Combined with the ability to create custom CSS functions, this opens up patterns that previously required preprocessors or JavaScript.

## What This Means

These features share a common theme: moving complexity out of JavaScript and into the platform. Native carousels, declarative dialogs, scroll-aware styling, conditional logic—the browser handles more, your bundle ships less.

The web platform is maturing. CSS in 2025 isn't the CSS of ten years ago. It's becoming a powerful, ergonomic toolkit for building dynamic applications.

Check out the full interactive experience at [chrome.dev/css-wrapped-2025](https://chrome.dev/css-wrapped-2025/).
